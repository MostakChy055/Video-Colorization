# -*- coding: utf-8 -*-
"""flow_vis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ySxifz87rxUFu4yjLZ9Jf55qjHVfBfkV
"""

# This function generates a color wheel specifically designed for visualizing optical flow.
# A color wheel is a visual representation of colors arranged in a circular pattern, often used in art and design.
# Optical flow represents the motion of image points between two consecutive frames. It's a 2D vector field where each pixel has an associated velocity vector. Directly visualizing these vectors can be challenging for humans to interpret. A color wheel maps the direction and magnitude of the flow vectors to colors:

# Direction: The hue (color) of the pixel represents the direction of the flow vector. Different hues correspond to different directions.
# Magnitude: The saturation or intensity of the color represents the magnitude of the flow vector. Brighter colors typically indicate larger flow magnitudes.

import numpy as np

def make_colorwheel():
    # These variables define the number of color steps for each segment of the color wheel (red-yellow, yellow-green, etc.). Steps in this context refer to the number of discrete color transitions within a particular segment of the color wheel. For example, RY = 15 means there are 15 steps or gradations from red to yellow within that segment. This results in a smoother color transition rather than a sudden jump from red to yellow
    RY = 15
    YG = 6
    GC = 4
    CB = 11
    BM = 13
    MR = 6

    # Calculates the total number of colors in the color wheel by summing up the lengths of all segments. Creates a NumPy array to store the color wheel, with ncols rows (one for each color) and 3 columns (RGB values).
    ncols = RY + YG + GC + CB + BM + MR
    colorwheel = np.zeros((ncols, 3))
    col = 0

    # RY
    # 0 theke RY - 1 porjonto first channel (Red) maximum intensity 255, second channel (Green)
    colorwheel[0:RY, 0] = 255
    colorwheel[0:RY, 1] = np.floor(255*np.arange(0,RY)/RY)
    col = col+RY
    # YG
    # COL theke COL + YG - 1 porjonto second channel (Green) maximum intensity 255, first channel (Red)
    colorwheel[col:col+YG, 0] = 255 - np.floor(255*np.arange(0,YG)/YG)
    colorwheel[col:col+YG, 1] = 255
    col = col+YG
    # GC
    colorwheel[col:col+GC, 1] = 255
    colorwheel[col:col+GC, 2] = np.floor(255*np.arange(0,GC)/GC)
    col = col+GC
    # CB
    colorwheel[col:col+CB, 1] = 255 - np.floor(255*np.arange(CB)/CB)
    colorwheel[col:col+CB, 2] = 255
    col = col+CB
    # BM
    colorwheel[col:col+BM, 2] = 255
    colorwheel[col:col+BM, 0] = np.floor(255*np.arange(0,BM)/BM)
    col = col+BM
    # MR
    colorwheel[col:col+MR, 2] = 255 - np.floor(255*np.arange(MR)/MR)
    colorwheel[col:col+MR, 0] = 255

    # One solid, then change, continue change, settle down (solid), solid, change
    return colorwheel


# This function converts optical flow components (u, v) into a color image for visualization. It utilizes a color wheel to map flow vectors to colors.
def flow_uv_to_colors(u, v, convert_to_bgr=False):
    """
    Args:
        u (np.ndarray): Input horizontal flow of shape [H,W]
        v (np.ndarray): Input vertical flow of shape [H,W]
        convert_to_bgr (bool, optional): Convert output image to BGR. Defaults to False.
    Returns:
        np.ndarray: Flow visualization image of shape [H,W,3]
    """

    #  Creates a numpy array of zeros with the same shape as the input flow components but with 3 channels (RGB) for the color image.
    flow_image = np.zeros((u.shape[0], u.shape[1], 3), np.uint8)
    # Gets the number of colors in the color wheel.
    colorwheel = make_colorwheel()  # shape [55x3]
    ncols = colorwheel.shape[0]
    # Calculates the magnitude of the flow vectors at each pixel. This line adds the squared horizontal and vertical components element-wise, resulting in the sum of squares for each pixel.
    rad = np.sqrt(np.square(u) + np.square(v))
    # Calculates the angle of the flow vectors in radians, normalized to the range [-1, 1].
    a = np.arctan2(-v, -u)/np.pi

    # Maps the angles to indices in the color wheel.
    # a+1: The angles are in the range of [-1, 1]. Adding 1 shifts the range to [0, 2].
    # / 2: Dividing by 2 scales the values to the range [0, 1].
    # *(ncols-1): Multiplies the scaled values by ncols-1. This maps the values to the range [0, ncols-1], which corresponds to the indices of the color wheel.
    # This mapping ensures that flow vectors with different angles are mapped to different color segments in the color wheel, providing a visual representation of the flow direction.
    fk = (a+1) / 2*(ncols-1)
    # Converts the result to a 32-bit integer data type, as indices are typically integers. The color wheel is a discrete representation of colors. To interpolate between colors, we need to identify the two closest colors in the color wheel to the desired color. The k0 index gives us the position of the first of these two colors.
    k0 = np.floor(fk).astype(np.int32)
    # Giving us the closest second color
    k1 = k0 + 1
    k1[k1 == ncols] = 0
    # The fractional part f represents the relative position of the desired color between the two colors at indices k0 and k1 in the color wheel. By using linear interpolation with this fractional value, we can smoothly transition between the two colors, creating a more accurate representation of the flow direction.
    f = fk - k0

    # Iterates over each color channel (3)
    for i in range(colorwheel.shape[1]):
        # Got the colors for thsi channel
        tmp = colorwheel[:,i]
        # Placing the indices to get color
        col0 = tmp[k0] / 255.0
        col1 = tmp[k1] / 255.0
        # Performs linear interpolation between col0 and col1 based on the fractional part f.
        col = (1-f)*col0 + f*col1
        # Creates a mask for flow magnitudes less than or equal to 1.
        idx = (rad <= 1)
        # Adjusts color intensity for flow magnitudes within the range [0, 1].
        col[idx]  = 1 - rad[idx] * (1-col[idx])
        # Adjusts color intensity for flow magnitudes greater than 1. As ~idx inverts the mask, so it becomes True for flow magnitudes greater than 1.
        col[~idx] = col[~idx] * 0.75   # out of range
        # Note the 2-i => BGR instead of RGB
        ch_idx = 2-i if convert_to_bgr else i
        flow_image[:,:,ch_idx] = np.floor(255 * col)
    return flow_image


# This function takes a 2D optical flow image as input, preprocesses it, and then calls the flow_uv_to_colors function to convert it into a color-coded image for visualization.
def flow_to_color(flow_uv, clip_flow=None, convert_to_bgr=False):
    """
    Expects a two dimensional flow image of shape.
    Args:
        flow_uv (np.ndarray): Flow UV image of shape [H,W,2]
        clip_flow (float, optional): Clip maximum of flow values. Defaults to None.
        convert_to_bgr (bool, optional): Convert output image to BGR. Defaults to False.
    Returns:
        np.ndarray: Flow visualization image of shape [H,W,3]
    """
    assert flow_uv.ndim == 3, 'input flow must have three dimensions'
    assert flow_uv.shape[2] == 2, 'input flow must have shape [H,W,2]'

    # If a maximum flow value is specified, clips the flow values to be within the range [0, clip_flow].
    if clip_flow is not None:
        flow_uv = np.clip(flow_uv, 0, clip_flow)

    # Extracts the horizontal and vertical flow component.
    u = flow_uv[:,:,0]
    v = flow_uv[:,:,1]
    rad = np.sqrt(np.square(u) + np.square(v))
    rad_max = np.max(rad)
    epsilon = 1e-5

    # Normalizes the horizontal flow component. This step ensures that the flow magnitudes are in the range of [0, 1].
    u = u / (rad_max + epsilon)
    v = v / (rad_max + epsilon)
    return flow_uv_to_colors(u, v, convert_to_bgr)